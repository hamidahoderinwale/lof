<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>pkl_outline – Loaf</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-a804b358defe67bda3b29790721414d7.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Loaf</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="./pkl_outline.html" aria-current="page"> 
<span class="menu-text">Project Overview</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./draftdviz.html"> 
<span class="menu-text">Data Viz Version Control</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./sci_indexing.html"> 
<span class="menu-text">New Gen Research Indexing</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>This research will apply the concept of the procedural knowledge library to the process of knowledge production itself.</p>
<p>A library is a curated, organized collection of ideas, concepts, and facts, transformed into structured representations that users can access, interpret, and understand. It bridges raw information and human knowledge, providing tools to make meaning accessible. Libraries take many forms, as information can be encoded in text, sound, images, data, and more.</p>
<p>While traditional libraries rely on static representations (e.g., printed books, fixed records), information is inherently dynamic. Today, we can also represent information dynamically—through interactive media, real-time data, and evolving digital archives. Libraries must adapt to these forms. Here, I focus on the digital medium and the dynamic artifacts it produces, such as the programs that live in repositories.</p>
<section id="preserving-the-model-development-process" class="level2">
<h2 class="anchored" data-anchor-id="preserving-the-model-development-process">Preserving the model-development process</h2>
<p>I envision that the core tenet of modern knowledge work will be model-building—finding the right representations of our goals, specifying them, and iteratively refining them over time. Furthermore, with AI, traditionally imperative workflows will shift toward a more declarative paradigm: users will define their goals rather than specifying the steps required to achieve them.</p>
<p>In short, we have a significant opportunity to improve insight generation by using procedural knowledge capture to document how models are built and how they evolve over time.</p>
</section>
</section>
<section id="project-overview" class="level1">
<h1>Project Overview</h1>
<p>This work is divided into two interconnected projects:</p>
<ol type="1">
<li><p>A <strong>conceptual framework</strong> for procedural knowledge libraries, which defines their core functions, challenges, and potential applications. In this work, I specifically want to focus on the graphical model-builders’ workflow as a case study. <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p></li>
<li><p>A <strong>practical implementation</strong> using <a href="https://github.com/davidad/chit">Chit</a>, an experimental version-control system, as a test-bed to explore how such libraries can handle dynamic artifacts like code-generated visualizations.</p></li>
</ol>
<section id="conceptual-framework" class="level2">
<h2 class="anchored" data-anchor-id="conceptual-framework">Conceptual framework</h2>
<div class="flushleft">
<p>The paper will include the following:</p>
</div>
</section>
<section id="version-control-for-structured-graphical-data" class="level2">
<h2 class="anchored" data-anchor-id="version-control-for-structured-graphical-data">Version Control for Structured Graphical Data</h2>
<section id="version-control-repositories-as-libraries" class="level3">
<h3 class="anchored" data-anchor-id="version-control-repositories-as-libraries">Version Control Repositories as Libraries</h3>
<p>While not traditionally viewed as such, version control systems like Git and their logs are libraries because they organize, preserve, and provide access to structured knowledge—documenting code evolution, decisions, and project histories. These dynamic artifacts act as repositories, lets users to interpret, understand, and build upon the work of others.</p>
<p>Visual representations reveal patterns in complex data that text alone cannot. Exploratory data analysis serves as a systematic method for sense-making through these visualizations. This project proposes insight provenance—capturing not just final visualizations but the journey of analysis that produced them. At large, I see this is a project of capturing the reasoning process, in this case, using visualizations to make sense of complex datasets.</p>
</section>
<section id="implementation" class="level3">
<h3 class="anchored" data-anchor-id="implementation">Implementation</h3>
<p>This project extends <a href="https://github.com/davidad/chit">Chit</a>, an experimental version-control system for structured data, to declarative graphical languages. Presently, developers using data visualization tools—such as <a href="https://observablehq.com/">Observable</a>, <a href="https://hex.tech/">Hex</a>, and <a href="https://jupyter.org/">Jupyter</a> notebooks—lack adequate version control systems suited for visual, exploratory, and iterative workflows. These workflows often involve open-ended methods to achieve an unstructured goal, making traditional file-based version control insufficient.</p>
<p>I will apply this system to graphical representations, such as <a href="https://vega.github.io/vega-lite/">Vega-Lite</a>–a high-level visualization grammar. As a library, it will incorporate version control to capture the process of creating and refining visualizations. Additionally, it will be extended to support core library functions, such as retrieving past history and enabling search across historical versions.</p>
<p>Given Chit’s experimental and early-stage nature, I plan to build my own understanding of its approach, extract its core principles, and develop a bespoke system tailored to procedural knowledge libraries. Where elements are retained from Chit, I will provide technical exposition to explain their design and rationale. <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>While still in its early stages, Chit lays a strong foundation for the broader project and aligns with my vision for the library of the future: a system that works with dynamic artifacts—such as code-generated visualizations—whose context must be organized and preserved. Chit was originally developed to help build auditable, interpretable AI systems while being extensible to less-structured personal knowledge and logic languages (e.g., SQL).</p>
</section>
<section id="informing-the-theory" class="level3">
<h3 class="anchored" data-anchor-id="informing-the-theory">Informing the theory</h3>
<p>This project serves as a test-bed to explore key questions that can inform the former:</p>
<ul>
<li><p>What trade-offs exist in designing an efficient yet expressive history-tracking system?</p></li>
<li><p>How can Chit handle visual representation changes, such as diffing and merging Vega-Lite specifications?</p></li>
<li><p>How could this extend to knowledge structures like RDF and OWL?</p></li>
</ul>
<p>The final work will fully explain why this specific interpretation of a "procedural knowledge library" was worth exploring. I will outline the attributes of this particular instance of a procedural knowledge library informed by the conceptual framework above. This will test the universal properties of a procedural knowledge library, including: the types of procedures it supports, their medium of representation, the features of the goals it targets, and the decision to extend Chit rather than starting from scratch.</p>
</section>
</section>
</section>
<section id="future-work" class="level1">
<h1>Future Work</h1>
<p>In my foundational research agenda, I outlined a series of questions. Here, I list some more that may or may not become the basis of future projects.</p>
<section id="diffing-ml-model-evolution" class="level2">
<h2 class="anchored" data-anchor-id="diffing-ml-model-evolution">Diffing ML model evolution</h2>
<p><a href="https://transformer-circuits.pub/2024/model-diffing/index.html">Model diffing</a> is a new ML interpretability technique in which LLMs are compared by analyzing their internal representations. We could potentially extend this by first having models generate graphical representations of their own internal structures (e.g.&nbsp;with <a href="https://github.com/hycis/TensorGraph">TensorGraph</a>). Then we apply model diffing and structured versioning techniques to the graphical representations they generate.</p>
<p>This approach could improve fine-tuning, enhance interpretability, and help researchers track model evolution over time. This builds on Gurnee and Tegmark’s (2024) <a href="https://arxiv.org/abs/2310.02207">work</a> finding that models learn linear representations of space and time.</p>
<p>While they manually visualized these representations, we might ask models to programmatically generate these visualizations themselves, perhaps expressing their reasoning in declarative graphical languages such as DOT (used by Graphviz), Mermaid, TikZ, D3.js, or ONNX. For example, a model could output its attention patterns as a Mermaid diagram, or express its learned spatial representations as TikZ code that researchers could then visualize, analyze, and compare across model versions.</p>
</section>
<section id="model-interoperability" class="level2">
<h2 class="anchored" data-anchor-id="model-interoperability">Model Interoperability</h2>
<ul>
<li><p>How can denotational semantics—a method of mathematically formalizing the meaning of programming operations—serve as a common framework for managing models across different programming languages?</p></li>
<li><p>How can we combine declarative programming paradigms with denotational techniques to better capture developer intentions?</p></li>
<li><p>What formal methods could be developed to ‘diff’ the semantic meaning and goals of code as it evolves over time, going beyond just analyzing syntactic changes?</p></li>
<li><p>Additionally, how can we enable reasoning about systems that mix formal, semi-formal, and informal representations?</p></li>
</ul>


</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Inspired by survey papers from ACM Transactions on Knowledge Discovery from Data: <a href="https://dl.acm.org/doi/pdf/10.1145/3363574#page=6.82">1</a>, <a href="https://dl.acm.org/doi/pdf/10.1145/3447822">2</a>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>For an example of a theory-driven implementation paper, see <em>Designing Datalog-Based Embedded Languages</em> at <a href="https://arxiv.org/abs/2305.14773">arXiv:2305.14773</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/hamidah\.quarto\.pub\/loaf");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>